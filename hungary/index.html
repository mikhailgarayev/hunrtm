<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RTM Dashboard - HUN</title>
<link rel="preconnect" href="https://sheets.googleapis.com" crossorigin>
<link rel="dns-prefetch" href="https://sheets.googleapis.com">
<link rel="icon" type="image/png" href="favicon.png" />
<style>
  :root{
    --bg:#0b0f19;
    --card:#121829;
    --muted:#8b93a7;
    --accent:#4f8cff;
    --good:#34d399;
    --warn:#fbbf24;
    --bad:#f87171;
    --ring: rgba(79,140,255,.35);
    --overlay: rgba(3,8,23,.6);
  }
  *{box-sizing:border-box}
  html,body{height:100%}

  body{
    margin:0;
    font: 16px/1.5 system-ui,-apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
    color:#e8eefc;
    background: var(--bg);
    position: relative;
    overflow-x: hidden;
  }
  body::before{
    content:"";
    position: fixed; inset:-20% -20% -20% -20%;
    pointer-events:none; z-index:-1;
    background:
      radial-gradient(70vw 70vw at -12% -12%, rgba(22,33,62,.55) 0%, rgba(22,33,62,.35) 40%, rgba(22,33,62,.12) 65%, rgba(22,33,62,0) 80%),
      radial-gradient(85vw 85vw at 112% -6%, rgba(14,27,52,.45) 0%, rgba(14,27,52,.22) 55%, rgba(14,27,52,0) 75%);
    background-repeat:no-repeat;
  }
  @media (min-width: 1800px){
    body::before{
      background:
        radial-gradient(80vw 80vw at -12% -12%, rgba(22,33,62,.55) 0%, rgba(22,33,62,.35) 40%, rgba(22,33,62,.12) 66%, rgba(22,33,62,0) 82%),
        radial-gradient(95vw 95vw at 112% -6%, rgba(14,27,52,.45) 0%, rgba(14,27,52,.22) 56%, rgba(14,27,52,0) 76%);
    }
  }

  .wrap{ max-width: 1600px; margin:24px auto; padding:0 16px 64px; }

  header{display:grid;gap:16px;grid-template-columns: repeat(4, minmax(0,1fr));align-items:stretch;margin-bottom:20px}

  .kpi{position:relative;padding:16px 18px;border-radius:16px;background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));backdrop-filter: blur(6px);border:1px solid rgba(255,255,255,.08);box-shadow: 0 10px 30px rgba(0,0,0,.35), 0 0 0 1px var(--ring) inset;display:grid;align-content:center;min-height:110px}
  .kpi h3{margin:0 0 6px;font-size:13px;font-weight:600;color:var(--muted);letter-spacing:.4px;text-transform:uppercase}
  .kpi .val{font-size:40px;font-weight:800;letter-spacing:1px}
  .kpi.small .val{font-size:14px; font-weight:600; white-space:pre-wrap}

  .pill{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;font-size:13px;border:1px solid rgba(255,255,255,.09);background:rgba(255,255,255,.04);color:#d6dcf5;cursor:default}
  .btn{cursor:pointer;transition:.2s transform ease}
  .btn:hover{transform:translateY(-1px)}
  .last-updated{justify-self:end}

  .grid{display:grid;gap:18px;grid-template-columns: 1fr}
  @media (min-width: 1000px){.grid{grid-template-columns: repeat(3, 1fr)}}
  /* UPCOMING: 4 колонки на широких; боковые карточки фиксируем в 4-й колонке */
  @media (min-width:1300px){
    .grid{
      /* 3 контентные колонки + ШИРОКАЯ правая */
      grid-template-columns: 1fr 1fr 1fr 2.1fr; /* сделай 2.3fr, если нужно ещё шире */
      align-items: start;
      grid-auto-flow: row; /* обычная укладка */
    }

    /* новая правая колонка */
    .side-col{
      grid-column: 4;             /* всегда в 4-й колонке */
      display: flex;              /* вертикальный стек внутри */
      flex-direction: column;
      gap: 18px;                  /* расстояние между карточками */
      align-self: start;          /* прилипает к верху строки */
      /* Опционально, чтобы правая колонка была видна при скролле: */
      /* position: sticky; top: 0; */
    }

    /* чтобы правая колонка использовала всю ширину своего столбца */
    .side-col .card{ width: 100%; }
  }



  .card{background: var(--card);border:1px solid rgba(255,255,255,.08);border-radius:16px;box-shadow: 0 12px 38px rgba(0,0,0,.35);overflow:hidden}
  .card header{display:flex;align-items:center;gap:10px;padding:14px 16px;border-bottom:1px solid rgba(255,255,255,.08);background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));margin:0}
  .card header h2{margin:0; font-size:16px; font-weight:700; letter-spacing:.2px}
  .badge{font-size:12px; padding:2px 8px; border-radius:8px; background:rgba(255,255,255,.06); color:var(--muted); border:1px solid rgba(255,255,255,.08)}
  table{width:100%; border-collapse:collapse}
  th,td{padding:10px 12px; text-align:left; border-bottom:1px dashed rgba(255,255,255,.08)}
  th{font-size:12px; text-transform:uppercase; letter-spacing:.3px; color:var(--muted)}
  tbody tr:hover{background:rgba(255,255,255,.03)}
  .status{font-weight:600}
  .status.On\ shift{color:var(--good)}
  .status.Off\ shift{color:var(--muted)}
  .status.Away{color:var(--bad)}
  .status.Pre-Away{color:var(--warn)}
  .footer-note{color:var(--muted); font-size:12px; padding:10px 14px}

  .blink{animation: pulse 1.5s infinite}
  @keyframes pulse {0%{opacity:1} 50%{opacity:.6} 100%{opacity:1}}
  .flex{display:flex; align-items:center; gap:8px}

  /* Modal */
  .overlay{position:fixed;inset:0;background:var(--overlay);backdrop-filter: blur(4px);opacity:0;pointer-events:none;transition: .2s opacity ease}
  .overlay.show{opacity:1;pointer-events:auto}
  .modal{
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.95);
    max-width: 980px; width: 92%;
    background: var(--card); border:1px solid rgba(255,255,255,.12); border-radius:16px; opacity:0; transition: .25s all ease; box-shadow: 0 20px 60px rgba(0,0,0,.55)
  }
  .overlay.show .modal{transform: translate(-50%, -50%) scale(1); opacity:1}
  .modal header{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid rgba(255,255,255,.08)}
  .modal h3{margin:0;font-size:18px}
  .modal .controls{display:flex;gap:10px;align-items:center}
  .modal .search{min-width:280px;padding:10px 12px;border-radius:12px;background:#0e1424;border:1px solid rgba(255,255,255,.12);color:#e8eefc;outline:none}
  .modal .close{border:none;background:transparent;color:#cbd3ea;font-size:22px;cursor:pointer}
  .modal .body{max-height:70vh;overflow:auto}
  .modal table thead th{position:sticky;top:0;background:rgba(18,24,41,.98);backdrop-filter: blur(6px)}
  .hint{font-size:12px;color:var(--muted);padding:8px 16px 0}


  .search-wrap{position: relative; display:flex; align-items:center; border:1px solid rgba(255,255,255,.09); background:rgba(255,255,255,.04); color:#d6dcf5; border-radius:999px; height:40px; padding:0 10px; cursor:pointer; transition:.25s all ease; min-width: 40px;}
  .search-wrap svg{position: absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:16px; height:16px; pointer-events:none;}
  .search-wrap input{border:none; outline:none; background:transparent; color:#e8eefc; font:inherit; width:0; opacity:0; position:absolute; right:12px; transition:.25s width ease, .2s opacity ease;}
  .search-wrap.open{padding:0 12px;}
  .search-wrap.open svg{position: static; transform:none; margin-right:8px;}
  .search-wrap.open input{position: static; width: 180px; opacity:1;}

  tr.match-active   { background: rgba(52,211,153,.15) !important; box-shadow: inset 0 0 0 1px rgba(52,211,153,.35); }
  tr.match-pre      { background: rgba(251,191,36,.15) !important; box-shadow: inset 0 0 0 1px rgba(251,191,36,.35); }
  tr.match-away     { background: rgba(248,113,113,.15) !important; box-shadow: inset 0 0 0 1px rgba(248,113,113,.35); }
  tr.match-active td b, tr.match-pre td b, tr.match-away td b { font-weight:800 }

  /* ссылки в ячейках имён */
  td.name-cell a{ color:#e8eefc; text-decoration:none; border-bottom:1px dotted rgba(255,255,255,.28); }
  td.name-cell a:hover{ color: var(--accent); border-bottom-color: var(--accent); }

  /* кнопки */
  #btnShifts, #btnStats{ border-color: rgba(79,140,255,.45); color:#e9f1ff; }
  #btnShifts:hover, #btnStats:hover{ background: rgba(79,140,255,.28); box-shadow: 0 0 0 2px var(--ring) inset; }
  .support-link{ border-color: rgba(79,140,255,.45); text-decoration:none; cursor:pointer; }
  .support-link:hover{ background:rgba(79,140,255,.25); border-color:var(--accent); color:#fff; }
  
  /* KPI themes */
  .kpi--active{ background:linear-gradient(180deg, rgba(34,197,94,.18), rgba(34,197,94,.08)); border-color: rgba(34,197,94,.45); box-shadow: 0 10px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(34,197,94,.25) inset; }
  .kpi--should{ background:linear-gradient(180deg, rgba(59,130,246,.18), rgba(59,130,246,.08)); border-color: rgba(59,130,246,.45); box-shadow: 0 10px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(59,130,246,.25) inset; }
  .kpi--pre{ background:linear-gradient(180deg, rgba(245,158,11,.18), rgba(245,158,11,.08)); border-color: rgba(245,158,11,.45); box-shadow: 0 10px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(245,158,11,.25) inset; }
  .kpi--away{ background:linear-gradient(180deg, rgba(239,68,68,.18), rgba(239,68,68,.08)); border-color: rgba(239,68,68,.45); box-shadow: 0 10px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(239,68,68,.25) inset; }
  .kpi--muted{ background:linear-gradient(180deg, rgba(148,163,184,.20), rgba(148,163,184,.08)); border-color: rgba(148,163,184,.45); box-shadow: 0 10px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(148,163,184,.22) inset; }

  /* --- collapsible cards --- */
  .card.collapsible header{
    display:flex; align-items:center; gap:10px; justify-content:space-between;
  }
  .card .head-left{ display:flex; align-items:center; gap:10px; }
  .card .head-right{ display:flex; align-items:center; gap:10px; }

  .card .toggle{
    width:28px; height:28px;
    display:inline-flex; align-items:center; justify-content:center;
    border-radius:8px; border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.04); color:#cfd6f3; cursor:pointer;
    transition:.2s transform ease, .2s background ease;
  }
  .card .toggle:hover{ background:rgba(255,255,255,.08); }
  .card .toggle svg{ width:14px; height:14px; transition:.2s transform ease; }

  .collapsible-body{
    overflow:hidden;
    transition: max-height .28s ease;
  }

  /* когда свернуто */
  .card.is-collapsed .collapsible-body{ max-height: 0 !important; padding-top:0; padding-bottom:0; }
  .card.is-collapsed .toggle svg{ transform: rotate(-90deg); } /* стрелка вбок */
  .segmented{
  display:inline-flex; border:1px solid rgba(255,255,255,.15);
  border-radius:10px; overflow:hidden; margin-right:8px;
  }
  .segmented button{
    background:transparent; color:#cfd6f3; border:none; padding:8px 10px;
    font:inherit; cursor:pointer;
  }
  .segmented button:not(:last-child){ border-right:1px solid rgba(255,255,255,.12); }
  .segmented button.active{ background:rgba(79,140,255,.25); color:#fff; }
  .segmented button:hover{ background:rgba(255,255,255,.08); }
  /* цветные бейджи для счётчиков */
  .badge--active {
    background: rgba(34,197,94,.2);   /* зелёный фон */
    border-color: rgba(34,197,94,.5);
    color: #34d399;                   /* зелёный текст */
  }

  .badge--pre {
    background: rgba(245,158,11,.2);  /* жёлто-оранжевый */
    border-color: rgba(245,158,11,.5);
    color: #fbbf24;
  }

  .badge--away {
    background: rgba(239,68,68,.2);   /* красный */
    border-color: rgba(239,68,68,.5);
    color: #f87171;
  }
 .logo {
  height: 50px;       /* высота логотипа */
  margin-right: 15px; /* отступ справа */
  margin-left: 25px;
  margin-bottom: 15px;
  flex-shrink: 0;     /* не сжимать при переполнении */
}

@media (max-width: 768px) {
  .logo {
    height: 22px;   /* чуть меньше на мобильных */
    margin-right: 8px;
  }
}

</style>
</head>
<body>



  <div class="wrap">
    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px">
      <div class="flex">
        <img id="logo" src="frame1.gif" alt="Wolt logo" class="logo" />
        <div class="pill">Support Monitoring Dashboard - Hungary</div>
        <div class="pill btn" id="btnShifts">Today’s shifts</div>
        <div class="pill btn" id="btnStats">Statistics</div>

        <div class="search-wrap" id="searchWrap" title="Search teammates">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M21 21l-4.2-4.2M10.8 18a7.2 7.2 0 1 1 0-14.4 7.2 7.2 0 0 1 0 14.4z" stroke="currentColor" stroke-width="1.7" stroke-linecap="round"/></svg>
          <input id="globalSearch" type="search" placeholder="Search teammate" />
        </div>
      </div>

      <div style="display:flex; align-items:center; gap:12px; justify-self:end">
        <a href="https://app.slack.com/client/E033H7MNDS5/C0999U4TYA0" target="_blank" class="pill support-link">Support</a>
        <div class="pill last-updated" id="lastUpdated">—</div>
      </div>
    </div>

    <header>
      <div class="kpi kpi--active"><h3>On shift now</h3><div class="val" id="kpi-onshift">—</div></div>
      <div class="kpi kpi--should"><h3>Should be</h3><div class="val" id="kpi-shouldbe">—</div></div>
      <div class="kpi kpi--pre"><h3>Pre-Away</h3><div class="val" id="kpi-preaway">—</div></div>
      <div class="kpi kpi--away"><h3>Away</h3><div class="val" id="kpi-away">—</div></div>

      <div class="kpi small" style="grid-column: span 2"><h3>Will not attend the shift</h3><div class="val" id="kpi-wnats">—</div></div>
      <div class="kpi small" style="grid-column: span 2"><h3>Not here</h3><div class="val" id="kpi-nothere">—</div></div>
    </header>

    <section class="grid">
      <div class="card">
        <header><h2>Active teammates</h2><span class="badge badge--active" id="activeCount">0</span></header>
        <div class="table-wrap">
          <table id="tbl-active"><thead><tr><th>Teammate</th><th>Status</th><th>Duration</th></tr></thead><tbody></tbody></table>
        </div>
        <div class="footer-note">Source: <b>RTM</b> sheet, columns A:E</div>
      </div>

      <div class="card">
        <header><h2>Pre-Away teammates</h2><span class="badge badge--pre" id="preCount">0</span></header>
        <div class="table-wrap">
          <table id="tbl-pre"><thead><tr><th>Teammate</th><th>Reason</th><th>Duration</th></tr></thead><tbody></tbody></table>
        </div>
        <div class="footer-note">Source: <b>RTM</b> sheet, columns H:M</div>
      </div>

      <div class="card">
        <header><h2>Away teammates</h2><span class="badge badge--away" id="awayCount">0</span></header>
        <div class="table-wrap">
          <table id="tbl-away"><thead><tr><th>Teammate</th><th>Reason</th><th>Time left</th></tr></thead><tbody></tbody></table>
        </div>
        <div class="footer-note">Source: <b>RTM</b> sheet, columns P:V</div>
      </div>

      <div class="side-col"> 
      <!-- Upcoming Shifts -->
      <div class="card collapsible" id="card-upcoming-starts">
        <header>
          <div class="head-left">
            <h2>Upcoming Shifts (next hour)</h2>
            <span class="badge" id="upStartCount">0</span>
          </div>
          <div class="head-right">
            <button class="toggle" data-target="card-upcoming-starts" title="Collapse/expand">
              <!-- caret-down -->
              <svg viewBox="0 0 24 24" fill="none"><path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
            </button>
          </div>
        </header>

        <div class="collapsible-body">
          <div class="table-wrap">
            <table id="tbl-upcoming-starts">
              <thead><tr><th>Teammate</th><th>Shift type</th><th>Start</th><th>End</th></tr></thead>
              <tbody></tbody>
            </table>
          </div>
          <div class="footer-note">Source: <b>Current Shift</b> sheet, columns A:F</div>
        </div>
      </div>

      <!-- Upcoming Shift ends -->
      <div class="card collapsible" id="card-upcoming-ends">
        <header>
          <div class="head-left">
            <h2>Upcoming Shift ends (next hour)</h2>
            <span class="badge" id="upEndCount">0</span>
          </div>
          <div class="head-right">
            <button class="toggle" data-target="card-upcoming-ends" title="Collapse/expand">
              <svg viewBox="0 0 24 24" fill="none"><path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
            </button>
          </div>
        </header>

        <div class="collapsible-body">
          <div class="table-wrap">
            <table id="tbl-upcoming-ends">
              <thead><tr><th>Teammate</th><th>Shift type</th><th>Start</th><th>End</th></tr></thead>
              <tbody></tbody>
            </table>
          </div>
          <div class="footer-note">Source: <b>Current Shift</b> sheet, columns A:F</div>
        </div>
      </div>
      <!-- Agents without scheduled break -->
<!-- Agents without scheduled break -->
<div class="card collapsible" id="card-breakless">
  <header>
    <div class="head-left">
      <h2>Teammates on shift without a scheduled break</h2>
      <span class="badge" id="breaklessCount">0</span>
    </div>
    <div class="head-right">
      <button class="toggle" data-target="card-breakless" title="Collapse/expand">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </button>
    </div>
  </header>

  <div class="collapsible-body">
    <div class="table-wrap">
      <table id="tbl-breakless">
        <thead><tr><th>Teammate</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="footer-note">
      Source: <b>For dashboard list</b>(A2:A) — doc <code>HUN Break regulation</code>
    </div>
  </div>
</div>
<!-- Breaks -->
<div class="card collapsible" id="card-breaks">
  <header>
    <div class="head-left">
      <h2>Breaks</h2>
      <span class="badge" id="breaksCount">0</span>
    </div>
    <div class="head-right">
      <div class="segmented" id="breaksFilter">
        <button data-mode="all" class="active">All</button>
        <button data-mode="upcoming">Upcoming</button>
      </div>
      <button class="toggle" data-target="card-breaks" title="Collapse/expand">
        <svg viewBox="0 0 24 24" fill="none"><path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
      </button>
    </div>
  </header>

  <div class="collapsible-body">
    <div class="table-wrap">
      <table id="tbl-breaks">
        <thead>
          <tr>
            <th>Teammate</th>
            <th>Start</th>
            <th>End</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="footer-note">
      Source: <b>Today’s shifts</b> (C, J:S) — <code>HUN break regulation</code>
    </div>
  </div>
</div>


      </div>
    </section>
  </div>

  <!-- Shifts modal -->
  <div class="overlay" id="dlgShifts">
    <div class="modal">
      <header>
      <h3>Today’s shifts</h3>

      <div class="controls">
        <!-- NEW: date filters -->
        <div class="segmented" id="shiftDayFilter">
          <button data-day="yesterday">Yesterday</button>
          <button data-day="today" class="active">Today</button>
          <button data-day="tomorrow">Tomorrow</button>
          <button data-day="all">All</button>
        </div>

        <input id="shiftSearch" class="search" type="search"
              placeholder="Search by name, email or badge…" />
        <button title="Close" class="close" id="closeShifts">✕</button>
      </div>
    </header>

      <div class="hint">Source: <b>Current Shift</b> sheet (A:F)</div>
      <div class="body">
        <table id="tbl-shifts">
          <thead><tr><th>Badge no.</th><th>Employee email</th><th>Employee name</th><th>Shift type</th><th>Start</th><th>End</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>
<!-- Statistics modal -->
<div class="overlay" id="dlgStats">
  <div class="modal">
    <header>
      <h3>Statistics (last 7 days, hourly)</h3>
      <div class="controls">
        <button title="Close" class="close" id="closeStats">✕</button>
      </div>
    </header>
    <div class="hint">Source: <b>Statistics</b> sheet (A:C)</div>
    <div class="body" style="padding:12px 16px;">
      <canvas id="statsChart" width="900" height="420"></canvas>
    </div>
  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>


<script>
// === CONFIG ===
const SHEET_ID = "12gcER4PN-gE3sAOz5pj_ihT-cdmqA6XhSn2wCb-6ykk";
const API_KEY  = "AIzaSyCfTHMy3fauwqbopmDRiD5siI6hH4Fmn38";
const SHEET    = "RTM";
const SHIFT_SHEET = "Current Shift";
const EMP_SHEET = "Employee list";
// --- breaks source (другая таблица) ---
const BREAKLESS_SHEET_ID = "1m4tApcZvlH6dpzekrDqfNoT0YoA3kkGl6hAPwyO_9Oo";
const BREAKLESS_RANGE = "For dashboard!A2:A";
// --- Breaks from "Today's shifts" (same spreadsheet id as user gave) ---
const BREAKS_SHEET_ID = "1m4tApcZvlH6dpzekrDqfNoT0YoA3kkGl6hAPwyO_9Oo";
const BREAKS_RANGE    = "Today's shifts!C2:S"; // C name, J..S breaks

let breaksMode = 'all'; // 'all' | 'upcoming'
let cachedBreaks = [];  // нормализованные брейки (каждый как отдельная запись)

let REFRESH_MS = 45000; // 45 cек: можно потом подкрутить


// Ranges for the main dashboard + shifts + employee list
const ranges = [
  `${SHEET}!A2:E`,
  `${SHEET}!H2:M`,
  `${SHEET}!P2:V`,
  `${SHEET}!X2`,
  `${SHEET}!Z2`,
  `${SHEET}!AB2`,
  `${SHEET}!AD2`,
  `${SHEET}!X5`,
  `${SHEET}!Z5`
];

let cachedShifts = [];
let shiftQuery = "";
let empMap = new Map();

async function fetchRanges(){
  const base = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values:batchGet`;
  const params = [
    ...ranges.map(r => "ranges=" + encodeURIComponent(r)),
    "valueRenderOption=UNFORMATTED_VALUE",     // числа как числа
    "dateTimeRenderOption=FORMATTED_STRING",   // даты как текст
    "fields=valueRanges(range,values)",        // только нужное
    `key=${API_KEY}`
  ].join("&");

  const res = await fetch(`${base}?${params}`, { cache: "no-store" });
  if(!res.ok){ const t = await res.text(); throw new Error("Load error: " + res.status + " " + t); }
  return res.json();
}
async function fetchShiftsForModal(){
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/` +
              encodeURIComponent(`${SHIFT_SHEET}!A2:F`) +
              `?valueRenderOption=UNFORMATTED_VALUE&dateTimeRenderOption=FORMATTED_STRING&fields=values&key=${API_KEY}`;
  const r = await fetch(url, { cache: 'no-store' });
  if(!r.ok) throw new Error('Shifts load error: '+r.status);
  const j = await r.json();
  return (j.values || []).map(r => ({
    badge: r[0]||"", email: r[1]||"", name: r[2]||"", type: r[3]||"", start: r[4]||"", end: r[5]||""
  }));
}

async function fetchBreakless(){
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${BREAKLESS_SHEET_ID}/values/` +
              encodeURIComponent(BREAKLESS_RANGE) + `?key=${API_KEY}`;
  const res = await fetch(url, { cache: "no-store" });
  if(!res.ok){
    const t = await res.text();
    throw new Error("Breakless load error: " + res.status + " " + t);
  }
  const json = await res.json();
  const values = json.values || [];
  // Берём только непустые имена
  return values.map(r => (r[0] || "").trim()).filter(Boolean);
}
// Читаем Statistics!A2:C и корректно парсим "DD/MM/YYYY HH:MM:SS"
async function fetchStatsSeries(){
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/` +
              encodeURIComponent(`Statistics!A2:C`) +
              `?valueRenderOption=FORMATTED_VALUE&dateTimeRenderOption=FORMATTED_STRING&fields=values&key=${API_KEY}`;

  const r = await fetch(url, { cache: 'no-store' });
  if (!r.ok) throw new Error('stats load failed ' + r.status);
  const j = await r.json();
  const rows = j.values || [];

  function parseStatsDate(v){
    if (v == null) return null;

    if (typeof v === 'number') {
      // Excel/Google serial → JS Date
      const ms = Math.round((v - 25569) * 86400 * 1000);
      return new Date(ms);
    }

    const s = String(v).trim();

    // DD/MM/YYYY HH:MM[:SS]
    const m = s.match(/^(\d{1,2})[\/.](\d{1,2})[\/.](\d{4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
    if (m){
      const day = +m[1], mon = +m[2]-1, yr = +m[3];
      const hh = +m[4], mm = +m[5], ss = +(m[6]||0);
      return new Date(yr, mon, day, hh, mm, ss);
    }

    // fallback — ISO/нативное
    const d = new Date(s);
    return isNaN(d) ? null : d;
  }

  const points = rows.map(row => {
    const dt = parseStatsDate(row[0]);
    return {
      t: (dt && !isNaN(dt)) ? dt.toISOString() : null,
      active: Number(row[1] || 0),
      should: Number(row[2] || 0)
    };
  }).filter(p => p.t);

  // фильтр последней недели (оставь, если нужно)
  const cutoff = Date.now() - 7*24*60*60*1000;
  return points.filter(p => +new Date(p.t) >= cutoff);
}


function cell(v){ return (Array.isArray(v) && v.length && v[0]!==undefined) ? v[0] : (typeof v==="string"?v:""); }
let globalQuery = "";
const HIGHLIGHT_CLASSES = ["match-active","match-pre","match-away"];

function normalizeName(s){ return (s||"").toString().trim().replace(/\s+/g," ").toLowerCase(); }
function buildEmployeeMap(namesCol, idsCol){
  const map = new Map();
  const N = Math.max(namesCol.length, idsCol.length);
  for(let i=0;i<N;i++){
    const name = (namesCol[i]?.[0] || "").trim();
    const id   = (idsCol[i]?.[0] || "").trim();
    if(name && id) map.set(normalizeName(name), id);
  }
  return map;
}
// --- КЭШ КАРТЫ СОТРУДНИКОВ (12 часов) ---
const EMP_CACHE_KEY = 'empMapCacheV1';
const EMP_CACHE_TS  = 'empMapCacheV1:ts';
const EMP_CACHE_TTL = 12 * 60 * 60 * 1000; // 12h

function saveEmpMapToCache(map){
  try{
    localStorage.setItem(EMP_CACHE_KEY, JSON.stringify(Array.from(map.entries())));
    localStorage.setItem(EMP_CACHE_TS, String(Date.now()));
  }catch(e){ console.warn('Emp cache save failed', e); }
}

function loadEmpMapFromCache(){
  try{
    const ts = +(localStorage.getItem(EMP_CACHE_TS) || 0);
    if (!ts || (Date.now() - ts) > EMP_CACHE_TTL) return null;
    const arr = JSON.parse(localStorage.getItem(EMP_CACHE_KEY) || '[]');
    if (!Array.isArray(arr) || !arr.length) return null;
    return new Map(arr);
  }catch(e){
    return null;
  }
}
function valAt(row, idx){ return (row && row.length > idx ? row[idx] : ""); }
function isBreakCellBad(v){
  if (v == null) return true;
  const s = String(v).trim().toLowerCase();
  return !s || s === 'break not found';
}

// грузим 2 колонки из Employee list и строим Map
async function fetchEmployeeMapFresh(){
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values:batchGet?` +
    [
      "ranges=" + encodeURIComponent(`${EMP_SHEET}!C2:C`), // names
      "ranges=" + encodeURIComponent(`${EMP_SHEET}!H2:H`), // ids
      "valueRenderOption=UNFORMATTED_VALUE",
      "fields=valueRanges(values)",
      `key=${API_KEY}`
    ].join("&");
  const r = await fetch(url, { cache: 'no-store' });
  if(!r.ok) throw new Error('Employee list load error: '+r.status);
  const j = await r.json();
  const names = (j.valueRanges?.[0]?.values) || [];
  const ids   = (j.valueRanges?.[1]?.values) || [];
  return buildEmployeeMap(names, ids);
}

// гарантируем, что empMap есть: сначала кэш, при необходимости — сеть
async function ensureEmpMap(force=false){
  if(!force){
    const cached = loadEmpMapFromCache();
    if(cached){ empMap = cached; return; }
  }
  try{
    const fresh = await fetchEmployeeMapFresh();
    empMap = fresh;
    saveEmpMapToCache(fresh);
  }catch(e){
    console.error('ensureEmpMap failed', e);
  }
}
async function fetchBreaksRaw(){
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${BREAKS_SHEET_ID}/values/` +
              encodeURIComponent(BREAKS_RANGE) +
              `?valueRenderOption=UNFORMATTED_VALUE&dateTimeRenderOption=FORMATTED_STRING&fields=values&key=${API_KEY}`;
  const r = await fetch(url, { cache: 'no-store' });
  if(!r.ok) throw new Error('Breaks load error: '+r.status);
  const j = await r.json();
  return j.values || [];
}

// Превращаем строки в массив объектов брейков (каждый брейк отдельной записью)
function buildBreakList(rows){
  const OUT = [];
  rows.forEach(row=>{
    const name = (valAt(row, 0) || "").toString().trim(); // C
    if(!name) return;

    // индексы по 0-базе относительно С..S
    const pairs = [
      {type:'Unpaid', idx:1,  s: valAt(row, 9),  e: valAt(row,10)}, // J,K
      {type:'Unpaid', idx:2,  s: valAt(row,11), e: valAt(row,12)}, // L,M
      {type:'Paid',   idx:1,  s: valAt(row,13), e: valAt(row,14)}, // N,O
      {type:'Paid',   idx:2,  s: valAt(row,15), e: valAt(row,16)}, // P,Q  (в задании 'q' — берём Q)
      {type:'Paid',   idx:3,  s: valAt(row,17), e: valAt(row,18)}, // R,S
    ];

    let hasAnyValid = false;

    pairs.forEach(p=>{
      if (isBreakCellBad(p.s) || isBreakCellBad(p.e)) return;
      const sd = parseDateFlexible(p.s);
      const ed = parseDateFlexible(p.e);
      if(!sd || !ed || isNaN(sd) || isNaN(ed)) return;

      hasAnyValid = true;
      OUT.push({
        name,
        type: `${p.type} ${p.idx}`,
        start: sd,
        end: ed
      });
    });

    // если по сотруднику все брейки "break not found"/пустые — мы просто его пропускаем (по ТЗ)
    if(!hasAnyValid){ /* skip entirely */ }
  });

  // Для красоты сортируем по старту
  OUT.sort((a,b)=> a.start - b.start);
  return OUT;
}
function renderStats(points){
  const labels = points.map(p => new Date(p.t));
  const active = points.map(p => p.active);
  const should = points.map(p => p.should);

  const ctx = document.getElementById('statsChart').getContext('2d');
  if (statsChart) statsChart.destroy();

  statsChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [
        { label: 'Active',    data: active, borderWidth: 2, tension: 0.25, pointRadius: 1 },
        { label: 'Should be', data: should, borderWidth: 2, tension: 0.25, pointRadius: 1 },
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          type: 'time',
          time: { unit: 'hour', tooltipFormat: 'MMM d, HH:mm' },
          ticks: { maxRotation: 0, autoSkip: true }
        },
        y: { beginAtZero: true, grace: '5%' }
      },
      plugins: {
        legend: { position: 'top' },
        tooltip: { mode: 'index', intersect: false }
      },
      interaction: { mode: 'nearest', axis: 'x', intersect: false }
    }
  });
}

function inboxLinkHTML(name){
  const id = empMap.get(normalizeName(name));
  if(!id) return name;
  const url = `https://ops.wolt.com/support/converse/users/conversations?assigneeIds=${encodeURIComponent(id)}`;
  return `<a href="${url}" target="_blank" rel="noopener">${name}</a>`;
}

// Заменить существующую parseDateFlexible на эту
function parseDateFlexible(val){
  if (val == null) return null;
  const s = String(val).replace(/\u00A0/g, ' ').trim(); // NBSP → пробел

  // 1) Жёстко поддерживаем "DD/MM/YYYY HH:MM[:SS]" (или с '.' или '-')
  //    Пример: 02/09/2025 13:00:00
  const m = s.match(
    /^(\d{1,2})[\/.\-](\d{1,2})[\/.\-](\d{2}|\d{4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?$/
  );
  if (m) {
    let day = +m[1], mon = +m[2] - 1, yr = +m[3];
    if (yr < 100) yr += 2000;
    const hh = +m[4], mm = +m[5], ss = +(m[6] || 0);
    return new Date(yr, mon, day, hh, mm, ss); // локальная таймзона (например Europe/Budapest)
  }

  // 2) Запасной вариант — пусть попробует нативный парсер
  const d = new Date(s);
  if (!isNaN(d)) return d;

  // 3) Только время "HH:MM[:SS]" → сегодня
  const t = s.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
  if (t) {
    const now = new Date();
    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), +t[1], +t[2], +(t[3] || 0), 0);
  }

  return null;
}


function fmtTime(d){
  if(!(d instanceof Date) || isNaN(d)) return "";
  return d.toLocaleTimeString(undefined, {hour:'2-digit', minute:'2-digit'});
}

// UPCOMING: получить массивы стартующих/заканчивающих в ближайший час
function computeUpcoming(shifts){
  const now = new Date();
  const starting = [];
  const ending   = [];

  shifts.forEach(r => {
    const startDt = parseDateFlexible(r.start);
    const endDt   = parseDateFlexible(r.end);

    if(startDt){
      const diffMin = (startDt - now) / 60000;
      if(diffMin >= 0 && diffMin <= 60){
        starting.push({ name:r.name, type:r.type, start:startDt, end:endDt });
      }
    }
    if(endDt){
      const diffMin = (endDt - now) / 60000;
      if(diffMin >= 0 && diffMin <= 60){
        ending.push({ name:r.name, type:r.type, start:startDt, end:endDt });
      }
    }
  });

  starting.sort((a,b)=> a.start - b.start);
  ending.sort((a,b)=> a.end - b.end);
  return { starting, ending };
}

function renderUpcomingCards(){
  const { starting, ending } = computeUpcoming(cachedShifts);

  const tbS = document.querySelector("#tbl-upcoming-starts tbody");
  const tbE = document.querySelector("#tbl-upcoming-ends tbody");
  tbS.innerHTML = ""; tbE.innerHTML = "";

  if(starting.length === 0){
    tbS.innerHTML = `<tr><td colspan="4" style="color:var(--muted)">—</td></tr>`;
  }else{
    starting.forEach(r=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="name-cell">${inboxLinkHTML(r.name)}</td><td>${r.type||""}</td><td>${fmtTime(r.start)}</td><td>${fmtTime(r.end)}</td>`;
      tbS.appendChild(tr);
    });
  }
  if(ending.length === 0){
    tbE.innerHTML = `<tr><td colspan="4" style="color:var(--muted)">—</td></tr>`;
  }else{
    ending.forEach(r=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="name-cell">${inboxLinkHTML(r.name)}</td><td>${r.type||""}</td><td>${fmtTime(r.start)}</td><td>${fmtTime(r.end)}</td>`;
      tbE.appendChild(tr);
    });
  }

  document.getElementById("upStartCount").textContent = starting.length;
  document.getElementById("upEndCount").textContent   = ending.length;
  refreshUpcomingHeights();

}
function renderBreakless(names){
  const tb = document.querySelector("#tbl-breakless tbody");
  if(!names || names.length === 0){
    tb.innerHTML = `<tr><td style="color:var(--muted)">—</td></tr>`;
  }else{
    tb.innerHTML = names.map(n => `<tr><td class="name-cell">${inboxLinkHTML(n)}</td></tr>`).join("");
  }
  document.getElementById("breaklessCount").textContent = String(names.length);
  const card = document.getElementById('card-breakless');
  if (card) refreshCollapsible(card);

}
function computeUpcomingBreaks(list){
  const now = new Date();
  return list.filter(b=>{
    const diffMin = (b.start - now) / 60000;
    return diffMin >= 0 && diffMin <= 60; // в ближайший час
  }).sort((a,b)=> a.start - b.start);
}

function renderBreaksCard(){
  const tb = document.querySelector("#tbl-breaks tbody");
  if(!tb) return;

  const rows = (breaksMode === 'upcoming') ? computeUpcomingBreaks(cachedBreaks) : cachedBreaks;

  tb.innerHTML = "";
  if(rows.length === 0){
    tb.innerHTML = `<tr><td colspan="3" style="color:var(--muted)">—</td></tr>`;
  }else{
    rows.forEach(b=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="name-cell">${inboxLinkHTML(b.name)}</td>
        <td>${fmtTime(b.start)}</td>
        <td>${fmtTime(b.end)}</td>`;
      tb.appendChild(tr);
    });
  }
  document.getElementById('breaksCount').textContent = String(rows.length);

  const card = document.getElementById('card-breaks');
  if (card) refreshCollapsible(card);
}

async function refreshBreaks(force=false){
  // Можно троттлить при желании; пока просто перезагружаем
  try{
    const raw = await fetchBreaksRaw();
    cachedBreaks = buildBreakList(raw);
    renderBreaksCard();
  }catch(e){
    console.error(e);
  }
}

// обновляем не чаще, чем раз в 90 секунд
let lastBreakFetch = 0;
async function maybeUpdateBreakless(force=false){
  const now = Date.now();
  if (!force && (now - lastBreakFetch) < 90000) return;
  try{
    const names = await fetchBreakless();
    renderBreakless(names);
    lastBreakFetch = now;
  }catch(e){ console.error(e); }
}
// первый вызов сразу:
maybeUpdateBreakless(true);
// дальше раз в 30 сек просто пробуем (функция сама решит, пора ли):
setInterval(()=> maybeUpdateBreakless(false), 30000);


function render(data){
  const [act, pre, aw, x2, z2, ab2, ad2, x5, z5] = data.valueRanges.map(v => v.values || []);

  // KPIs
  document.getElementById("kpi-onshift").textContent = cell(x2?.[0]) || "0";
  document.getElementById("kpi-shouldbe").textContent = cell(z2?.[0]) || "0";
  document.getElementById("kpi-preaway").textContent = cell(ab2?.[0]) || "0";
  document.getElementById("kpi-away").textContent = cell(ad2?.[0]) || "0";
  document.getElementById("kpi-wnats").textContent = (cell(x5?.[0]) || "—");
  document.getElementById("kpi-nothere").textContent = (cell(z5?.[0]) || "—");

  // ACTIVE
  const activeTbody = document.querySelector("#tbl-active tbody");
  activeTbody.innerHTML = "";
  let activeCount = 0;
  (act || []).forEach(row => {
    const [name,status,,, duration] = [row[0]||"", row[1]||"", row[2]||"", row[3]||"", row[4]||""];
    if(!name) return;
    activeCount++;
    const tr = document.createElement("tr");
    const stClass = "status " + (status||"").replace(/\s/g,"\\ ");
    tr.innerHTML = `<td class="name-cell">${inboxLinkHTML(name)}</td><td class="${stClass}">${status||""}</td><td>${duration||""}</td>`;
    activeTbody.appendChild(tr);
  });
  document.getElementById("activeCount").textContent = activeCount;

  // PRE-AWAY
  const preTbody = document.querySelector("#tbl-pre tbody");
  preTbody.innerHTML = "";
  let preCount = 0;
  (pre || []).forEach(row => {
    const name = row[0] || "";
    const reason = row[1] || "";
    const duration = row[4] || "";
    if(!name) return;
    preCount++;
    const tr = document.createElement("tr");
    tr.innerHTML = `<td class="name-cell">${inboxLinkHTML(name)}</td><td>${reason}</td><td>${duration}</td>`;
    preTbody.appendChild(tr);
  });
  document.getElementById("preCount").textContent = preCount;

  // AWAY
  const awayTbody = document.querySelector("#tbl-away tbody");
  awayTbody.innerHTML = "";
  let awayCount = 0;
  (aw || []).forEach(row => {
    const [name, reason,,,,, left] = [row[0]||"", row[1]||"", row[2]||"", row[3]||"", row[4]||"", row[5]||"", row[6]||""];
    if(!name) return;
    awayCount++;
    const tr = document.createElement("tr");
    tr.innerHTML = `<td class="name-cell">${inboxLinkHTML(name)}</td><td>${reason||""}</td><td>${left||""}</td>`;
    awayTbody.appendChild(tr);
  });
  document.getElementById("awayCount").textContent = awayCount;


  // Shifts modal table
  const input = document.getElementById("shiftSearch");
  shiftQuery = input.value;
  renderShiftsTable(shiftQuery?.trim() ? filterShiftsArray(shiftQuery) : cachedShifts);

  // header search подсветка
  applyGlobalSearch(globalQuery);

  const dt = new Date();
  document.getElementById("lastUpdated").textContent = "Updates every 45s. Last updated: " + dt.toLocaleTimeString();
}

function renderShiftsTable(rows){
  const tb = document.querySelector("#tbl-shifts tbody");
  tb.innerHTML = "";
  rows.forEach(r => {
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${r.badge}</td><td>${r.email}</td><td>${r.name}</td><td>${r.type}</td><td>${r.start}</td><td>${r.end}</td>`;
    tb.appendChild(tr);
  });
}

function filterShiftsArray(query){
  const q = (query||'').trim().toLowerCase();

  // 1) по дате (вчера/сегодня/завтра/все)
  let rows = cachedShifts.filter(pickDayFilter);

  // 2) поиск (если введён)
  if(q){
    rows = rows.filter(r =>
      (r.name||'').toLowerCase().includes(q) ||
      (r.email||'').toLowerCase().includes(q) ||
      String(r.badge||'').toLowerCase().includes(q)
    );
  }
  return rows;
}

function filterShifts(query){
  renderShiftsTable( filterShiftsArray(query) );
}

function clearHighlights(){
  HIGHLIGHT_CLASSES.forEach(cls => {
    document.querySelectorAll("tr."+cls).forEach(tr => tr.classList.remove(cls));
  });
}
function boldMatch(text, q){
  if(!q) return text;
  const i = text.toLowerCase().indexOf(q.toLowerCase());
  if(i === -1) return text;
  return text.substring(0,i) + "<b>" + text.substring(i, i+q.length) + "</b>" + text.substring(i+q.length);
}
function applyGlobalSearch(q){
  globalQuery = (q||"").trim();
  clearHighlights();
  if(!globalQuery) return;

  document.querySelectorAll("#tbl-active tbody tr").forEach(tr => {
    const nameCell = tr.children[0]; const nameTxt = nameCell.textContent || "";
    if(nameTxt.toLowerCase().includes(globalQuery.toLowerCase())){ tr.classList.add("match-active"); nameCell.innerHTML = boldMatch(nameTxt, globalQuery); }
  });
  document.querySelectorAll("#tbl-pre tbody tr").forEach(tr => {
    const nameCell = tr.children[0]; const nameTxt = nameCell.textContent || "";
    if(nameTxt.toLowerCase().includes(globalQuery.toLowerCase())){ tr.classList.add("match-pre"); nameCell.innerHTML = boldMatch(nameTxt, globalQuery); }
  });
  document.querySelectorAll("#tbl-away tbody tr").forEach(tr => {
    const nameCell = tr.children[0]; const nameTxt = nameCell.textContent || "";
    if(nameTxt.toLowerCase().includes(globalQuery.toLowerCase())){ tr.classList.add("match-away"); nameCell.innerHTML = boldMatch(nameTxt, globalQuery); }
  });
}

async function tick(){
  try{
    const json = await fetchRanges(); // только основной дашборд
    render(json);
  }catch(err){
    console.error(err);
    document.getElementById("lastUpdated").textContent =
      "Load failed — check access/API key";
  }
}


tick();
// ---- умная петля опроса с джиттером и паузой в фоне ----
const JITTER = 0.20; // ±20%

function nextDelay(){
  const k = 1 + (Math.random()*2 - 1) * JITTER; // 0.8..1.2
  return Math.max(10000, Math.floor(REFRESH_MS * k));
}

let tickerId = null;
async function loop(){
  try { await tick(); } catch(e){ console.error(e); }
  tickerId = setTimeout(loop, nextDelay());
}
// один раз на старте — не блокируем UI (без await)
ensureEmpMap(false);
// Подтянем смены отдельно для карточек "Upcoming …"
fetchShiftsForModal()
  .then(arr => { cachedShifts = arr; renderUpcomingCards(); })
  .catch(console.error);

// Обновлять раз в 5 минут
setInterval(async () => {
  try {
    const arr = await fetchShiftsForModal();
    cachedShifts = arr;
    renderUpcomingCards();
  } catch(e) { console.error(e); }
}, 5 * 60 * 1000);

// обновляем карту раз в 6 часов «на фоне»
setInterval(() => ensureEmpMap(true), 6 * 60 * 60 * 1000);

loop();

document.addEventListener('visibilitychange', ()=>{
  if (document.hidden){
    if (tickerId) clearTimeout(tickerId);   // не опрашиваем, когда вкладка не видна
  } else {
    loop();                                  // возобновляем
  }
});


// Modal wiring
const dlg = document.getElementById("dlgShifts");
document.getElementById("btnShifts").addEventListener("click", async () => {
  dlg.classList.add("show");
  try{
    if (!cachedShifts.length) {
      cachedShifts = await fetchShiftsForModal(); // грузим только 1-й раз
    }
    // если есть поисковый текст - отфильтруем, иначе покажем всё
    renderShiftsTable(shiftQuery ? filterShiftsArray(shiftQuery) : cachedShifts);
  }catch(e){
    console.error(e);
  }
});
// ==== Statistics modal wiring ====
const dlgStats = document.getElementById("dlgStats");
const btnStats = document.getElementById("btnStats"); // кнопка уже есть в шапке
const btnCloseStats = document.getElementById("closeStats");
let statsChart = null;

btnStats.addEventListener("click", async () => {
  dlgStats.classList.add("show");
  try {
    const series = await fetchStatsSeries();   // читаем лист Statistics
    renderStats(series);                       // рисуем график
  } catch (e) {
    console.error(e);
  }
});
btnCloseStats.addEventListener("click", () => dlgStats.classList.remove("show"));
dlgStats.addEventListener("click", (e)=>{ if(e.target===dlgStats) dlgStats.classList.remove("show"); });

document.getElementById("closeShifts").addEventListener("click", () => dlg.classList.remove("show"));
dlg.addEventListener("click", (e)=>{ if(e.target===dlg) dlg.classList.remove("show"); });

// Collapsible search
const searchWrap = document.getElementById('searchWrap');
const globalSearchInput = document.getElementById('globalSearch');
searchWrap.addEventListener('click', (e)=>{ if(!searchWrap.classList.contains('open')){ searchWrap.classList.add('open'); setTimeout(()=> globalSearchInput.focus(), 50);} e.stopPropagation(); });
document.addEventListener('click', ()=>{ if(globalQuery) return; searchWrap.classList.remove('open'); });
let gsTimer = null;
globalSearchInput.addEventListener('input', e=>{ const v = e.target.value; if(gsTimer) clearTimeout(gsTimer); gsTimer = setTimeout(()=> applyGlobalSearch(v), 120); });
globalSearchInput.addEventListener('keydown', e=>{ if(e.key === 'Escape'){ globalSearchInput.value = ""; globalQuery = ""; clearHighlights(); searchWrap.classList.remove('open'); }});

const searchInput = document.getElementById("shiftSearch");
searchInput.addEventListener("input", (e)=> { shiftQuery = e.target.value; filterShifts(shiftQuery); });

// segmented control wiring
document.getElementById('shiftDayFilter').addEventListener('click', (e)=>{
  const btn = e.target.closest('button[data-day]');
  if(!btn) return;
  shiftDay = btn.dataset.day;

  // UI: активная кнопка
  document.querySelectorAll('#shiftDayFilter button').forEach(b=> b.classList.remove('active'));
  btn.classList.add('active');

  // перерисовать таблицу с текущим поиском
  filterShifts(shiftQuery || '');
});

// ---- Collapsible helpers (с сохранением состояния в localStorage) ----
function setCollapsed(card, collapsed){
  const body = card.querySelector('.collapsible-body');
  // сперва выставим max-height для анимации
  if(!collapsed){
    // раскрываем
    body.style.maxHeight = body.scrollHeight + 'px';
    card.classList.remove('is-collapsed');
  }else{
    // сворачиваем
    body.style.maxHeight = body.scrollHeight + 'px'; // стартовое значение
    requestAnimationFrame(()=>{ body.style.maxHeight = '0px'; });
    card.classList.add('is-collapsed');
  }
  localStorage.setItem('collapsed:'+card.id, collapsed ? '1' : '0');
}

// Пересчитать высоту (когда внутри контент поменялся)
function refreshCollapsible(card){
  if(card.classList.contains('is-collapsed')) return;
  const body = card.querySelector('.collapsible-body');
  body.style.maxHeight = body.scrollHeight + 'px';
}

// Повесить слушатели на кнопку
function initCollapsible(cardId){
  const card = document.getElementById(cardId);
  if(!card) return;
  const btn = card.querySelector('.toggle');
  if(!btn) return;

  // восстановить состояние
  const saved = localStorage.getItem('collapsed:'+cardId) === '1';
  if(saved){
    card.classList.add('is-collapsed');
    card.querySelector('.collapsible-body').style.maxHeight = '0px';
  }else{
    // при первом рендере выставим нужную высоту
    refreshCollapsible(card);
  }

  btn.addEventListener('click', ()=>{
    const willCollapse = !card.classList.contains('is-collapsed');
    setCollapsed(card, willCollapse);
  });
}

// вызывать после наполняем таблицы upcoming
function refreshUpcomingHeights(){
  ['card-upcoming-starts','card-upcoming-ends'].forEach(id=>{
    const el = document.getElementById(id);
    if(el) refreshCollapsible(el);
  });
}
// карточка Breaks: collapsed + переключатель + первый рендер
initCollapsible('card-breaks');

document.getElementById('breaksFilter').addEventListener('click', (e)=>{
  const btn = e.target.closest('button[data-mode]');
  if(!btn) return;
  breaksMode = btn.dataset.mode;

  // UI
  document.querySelectorAll('#breaksFilter button').forEach(b=> b.classList.remove('active'));
  btn.classList.add('active');

  renderBreaksCard();
});

// первая загрузка и периодическое обновление
refreshBreaks(true);
// обновляем каждые 5 минут
setInterval(()=> refreshBreaks(false), 5 * 60 * 1000);

// запустить инициализацию после загрузки
initCollapsible('card-upcoming-starts');
initCollapsible('card-upcoming-ends');
initCollapsible('card-breakless');   

// полезно пересчитать на ресайз
window.addEventListener('resize', refreshUpcomingHeights);
// --- state for day filter ---
let shiftDay = 'today'; // 'yesterday' | 'today' | 'tomorrow' | 'all'

// вернуть только дату без времени в локальном TZ
function ymd(d){
  return [d.getFullYear(), d.getMonth(), d.getDate()].join('-');
}
function sameDay(a,b){ return ymd(a) === ymd(b); }

function pickDayFilter(r){ // r: {start, end} — строки из шитов
  if (shiftDay === 'all') return true;
  const start = parseDateFlexible(r.start);
  if (!start) return false;

  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  let target;

  if (shiftDay === 'yesterday'){
    target = new Date(today); target.setDate(target.getDate()-1);
  } else if (shiftDay === 'tomorrow'){
    target = new Date(today); target.setDate(target.getDate()+1);
  } else { // 'today'
    target = today;
  }
  return sameDay(start, target);
}
// --- логотип: статичная и анимационная гифки ---
const logo = document.getElementById('logo');
const staticLogo = "frame.gif";
const animatedLogo = "https://media.tenor.com/dRHmcsSmZaYAAAAj/wolt-delivery.gif";

// сколько держать анимацию (мс)
const ANIM_DURATION = 1700; // 4 сек

setInterval(() => {
  if (!logo) return;
  // переключаем на анимацию
  logo.src = animatedLogo;

  // через ANIM_DURATION возвращаем статичный кадр
  setTimeout(() => { logo.src = staticLogo; }, ANIM_DURATION);

}, 15000); // каждые 15 сек

</script>
</body>
</html>
